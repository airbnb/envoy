{#
  Template for 'request_metrics.h'.

  Generates the request metric names from Kafka message types.
  The metrics structure (KAFKA_REQUEST_METRICS) is wrapped by RichRequestMetrics instance, allowing
  for easier access to metrics using message's api_key.

  There is one metric for each of request types (e.g. produce) - number of responses received.
  There is also a metric for counting requests that could not be recognised, and one for requests
  that could caused deserialization errors.
#}

#pragma once

#include <array>
#include <functional>

#include "common/common/regex.h"
#include "common/runtime/runtime_impl.h"
#include "common/stats/symbol_table_impl.h"

#include "envoy/stats/scope.h"
#include "envoy/stats/stats_macros.h"

#include "extensions/filters/network/kafka/kafka_types.h"

namespace Envoy {
namespace Extensions {
namespace NetworkFilters {
namespace Kafka {

/**
 * Generated metrics, we have a counter for each request type.
 */
#define KAFKA_REQUEST_METRICS(COUNTER)                                                             \
{% for message_type in message_types %}                                                            \
  COUNTER({{ message_type.name_in_c_case() }})                                                     \
{% endfor %}                                                                                       \
  COUNTER(unknown)                                                                                 \
  COUNTER(failure)

struct KafkaRequestMetrics {
  KAFKA_REQUEST_METRICS(GENERATE_COUNTER_STRUCT)
};

/**
 * Abstraction layer over request-related metrics.
 * Pure interface so that it can be mocked easily.
 */
class RichRequestMetrics {
public:
  virtual ~RichRequestMetrics() = default;

  /**
   * Invoked when properly-parsed message is received.
   */
  virtual void onRequest(const int16_t api_key, const NullableString& client_id) PURE;

  /**
   * Invoked when an unknown message is received.
   */
  virtual void onUnknownRequest() PURE;

  /**
   * Invoked when a deserialization error occurs.
   */
  virtual void onBrokenRequest() PURE;
};

using RichRequestMetricsSharedPtr = std::shared_ptr<RichRequestMetrics>;

/**
 * Metrics implementation that uses Envoy Scope to store metrics.
 */
class RichRequestMetricsImpl: public RichRequestMetrics {
public:
  RichRequestMetricsImpl(Stats::Scope& scope, std::string stat_prefix): metrics_({
    KAFKA_REQUEST_METRICS(POOL_COUNTER_PREFIX(scope, fmt::format("kafka.{}.request.",
      stat_prefix)))}),
      scope_(scope),
      stat_name_set_(scope.symbolTable().makeSet("Kafka")),
      stat_prefix_(stat_prefix) {
    // TODO(amre): make two following parameters configurable
    all_tagged_metrics_sample_rate_ = 5;
    // instead of regex we could also simply check the prefix of a client id
    // but the regex is far more flexible.
    // This regex matches metrics *not* starting with "metadata-proxy." or "metadata-proxy"
    regex_ = Regex::Utility::parseStdRegexAsCompiledMatcher("^(?!(metadata-proxy(\\.|$)))");
  };

  void onRequest(const int16_t api_key, const NullableString& client_id) override {
    // Both successful message parsing & metrics list depend on protocol-generated code, what means
    // both do support the same api keys.
    std::string non_null_client_id = client_id ? *client_id : "unknown";
    switch (api_key) {
    {% for message_type in message_types %}
    case {{ message_type.get_extra('api_key') }} :
      // based on the configured rate (probabilistically)
      if (random_.random() % 100 <= all_tagged_metrics_sample_rate_) {
        scope_.counterFromStatName(stat_name_set_->add(
            absl::StrCat(
              fmt::format("kafka.{}.request.", stat_prefix_),
              "request_type.{{ message_type.name_in_c_case() }}.",
              fmt::format("client_id.{}", non_null_client_id)
            )
          )
        ).inc();
      }
      // special metric for client ids that matches the regex (e.g., not from metadata proxy)
      if (regex_ && regex_ -> match(non_null_client_id)) {
        scope_.counterFromStatName(stat_name_set_->add(
            absl::StrCat(
              fmt::format("kafka.{}.request.alert.", stat_prefix_),
              "request_type.{{ message_type.name_in_c_case() }}.",
              fmt::format("client_id.{}", non_null_client_id)
            )
          )
        ).inc();
      }
      metrics_.{{ message_type.name_in_c_case() }}_.inc();
      return;
    {% endfor %}
    }
  }

  void onUnknownRequest() override { metrics_.unknown_.inc(); }

  void onBrokenRequest() override { metrics_.failure_.inc(); }

private:
  KafkaRequestMetrics metrics_;
  Stats::Scope& scope_;
  Stats::StatNameSetPtr stat_name_set_;
  std::string stat_prefix_;
  Runtime::RandomGeneratorImpl random_;
  unsigned long all_tagged_metrics_sample_rate_;
  Regex::CompiledMatcherPtr regex_;
};

} // namespace Kafka
} // namespace NetworkFilters
} // namespace Extensions
} // namespace Envoy
